# **16장_ 트랜잭션과 락, 2차 캐시**

## **16.1 트랜잭션과 락**

### **16.1.1 트랜잭션과 격리 수준**

트랜잭션은 ACID라 하는 원자성, 일관성, 격리성, 지속성을 보장해야 한다.

- 원자성(Atomicity): 트랜잭션 내에서 실행한 작업들은 마치 하나의 작업인 것처럼 모두 성공하든가 모두 실패해야 한다.
- 일관성(Consistency): 모든 트랜잭션은 일관성 있는 데이터베이스 상태를 유지해야 한다. 예를 들어 데이터베이스에서 정한 무결성 제약 조건을 항상 만족해야 한다.
- 격리성(Isolation): 동시에 실행되는 트랜잭션들이 서로에게 영향을 미치지 않도록 격리한다. 예를 들어 동시에 같은 데이터를 수정하지 못하도록 해야 한다. 격리성은 동시성과 관련된 성능 이슈로 인해 격리 수준을 선택할 수 있다.
- 지속성(Durability): 트랜잭션을 성공적으로 끝내면 그 결과가 항상 기록되어야 한다. 중간에 시스템에 문제가 생기더라도 데이터베이스 로그 등을 사용해서 성공한 트랜잭션 내용을 복구해야 한다.

### **트랜잭션 격리 수준**

격리 수준이 낮을수록 동시성은 증가하지만 격리 수준에 따른 다양한 문제가 발생한다.

- 문제점
  - DIRTY READ
  - NON_REPEATABLE READ(반복 불가능한 읽기)
  - PHANTOM READ
- READ UNCOMMITED: 커밋하지 않은 데이터를 읽을 수 있다. 예를 들어 트랜잭션1이 데이터를 수정하고 있는데 커밋하지 않아도 트랜잭션2가 수정 중인 데이터를 조회할 수 있다. 이것을 DIRTY READ 라고 한다.
- READ COMMITED: 커밋한 데이터만 읽을 수 있다. DIRTY READ는 발생하지 않지만 NON_REPEATABLE READ는 발생할 수 있다. 반복해서 같은 데이터를 읽을 수 없는 상태를 NON_REPEATABLE READ라 한다.
- REPEATABLE READ: 한 번 조회한 데이터를 반복해서 조회해도 같은 데이터가 조회된다. 반복 조회 시 결과 집합이 달라질 수 있다.(PHANTOM READ)
- SERIALIZABLE: 가장 엄격한 트랜잭션 수준이다. 여기서는 PHANTOM READ가 발생하지 않는다. 하지만 동시성 처리 성능이 급격히 떨어질 수 있다.

### ***MVCC(Multi-Version Concurrency Control)***

> 데이터베이스에서 동시성을 제어하는 기법 중 하나로, 하나의 데이터를 여러 버전으로 관리하여 읽기 작업과 쓰기 작업이 충돌하지 않도록 하는 방법이다.
>

**MVCC가 필요한 이유**

- 일반적인 락 기반의 동시성 제어는 트랜잭션 간 경쟁이 발생하여 성능이 저하될 수 있다.
- MVCC는 락을 최소화하면서 동시에 읽기와 쓰기 작업을 수행할 수 있도록 설계된 방식이다.
- 최근에는 데이터베이스들이 더 많은 동시성 처리를 위해 락보다는 MVCC를 사용한다.

**동작 방식**

1. 각 트랜잭션이 데이터를 수정할 때 새로운 버전 생성
2. 읽기 작업(select)은 기존 버전을 참조
  1. READ COMMITED, REAPEATABLE READ 같은 격리 수준에 사용됨
3. 쓰기 작업(update, delete, insert)은 새로운 버전 생성
  1. update는 기존 데이터를 즉시 변경하는 것이 아니라, 새로운 버전을 생성함
  2. 이전 데이터를 참조하는 트랜잭션이 종료될 때까지 기존 데이터는 그대로 유지됨.
4. 불필요한 버전 삭제 (Garbage Collection)
  1. 데이터베이스는 GC 작업을 수행하여 불필요한 버전을 삭제함.

**장점**

- **읽기 작업이 블로킹되지 않음** → SELECT 시 락을 사용하지 않음
- **동시성 향상** → 여러 트랜잭션이 충돌 없이 동작 가능
- **트랜잭션 격리 수준 향상** → `REPEATABLE READ`에서 일관된 데이터 제공

**단점**

- **불필요한 데이터 버전이 증가** → **스토리지 공간이 많이 사용됨**
- **Garbage Collection 필요** → 불필요한 데이터 삭제 작업이 필요하여 성능 저하 가능
- **쓰기 작업이 많으면 성능 저하 가능** → 새로운 버전을 계속 생성해야 하므로 Overhead 발생